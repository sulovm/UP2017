# Домашно 4:


Решенията да се изпращат на upassistant2014@gmail.com.
Краен срок: 17 януари 2018 г.

Решението на всяка задача трябва да бъде под формата на файл с окончание .cpp (не целите проекти, ако използвате Visual Studio). 
Файловете се изпращат като attachment-и в mail-a. 
Освен решения на задачите, самият mail трябва да съдържа име и факултен номер. Успех!


### Задача 1 ###

 В програма да се дефинира функция int countMutualChar(const char* s1, const char* s2), която връща броя на общите за s1 и s2 символи.

#### Примери ####

```c++
scorpions antilopa
// -> 4 //общите символи са 'o', 'p', 'i' и 'n'

scorpions gazela
// -> 0 //няма общи символи
```

### Задача 2 ###

 В програма да се дефинира булева функция (връщаща резултат от тип bool) с име moreLettersThanOthers, която приема като параметър символен низ и връща true, ако в низа се срещат повече латински букви, отколкото други символи, и false в противен случай. Функцията трябва да приема още един, целочислен параметър, в който да се записва броят на буквите. Главни и малки лат. букви са неразличими в тази задача. Функцията трябва да гарантира, че подаденият низ не може да бъде променен.
 
#### Забележка ####

 Как гарантираме, че низът не може да бъде променен, и как трябва да подадем втория параметър, така че да можем да използваме записаната в него стойност в main ф-ята?

#### Примери ####

```c++
maroon5_Won't.Go.Home
// -> true    //във втория параметър трябва да сме записали 16

vt2875_A@<>=
// -> false   //във втория параметър трябва да сме записали 3
```
 
### Задача 3 ###

 В програма да се дефинира **рекурсивна** функция с име maxElemInArray, която намира максималния елемент в масив от цели числа а0, а1, ..., аn-1 (1 <= n <= 100).
 
#### Примери ####

```c++
5
1 12 34 7 10
// -> 34
```
 
### Задача 4 - Незадължителна ###

 Дадена е квадратна матрица (100 х 100) от цели числа, които могат да бъдат 0 или 1. Приемаме, че 0 означава, че клетката е проходима, а 1 - че не е. Може да се премине от клетка в друга клетка, ако двете клетки са съседни по хоризонтала или вертикала (но не и по диагонал), проходими са и няма да излезем извън матрицата. Казваме, че между две не непременно съседни клетки има път, ако може да се стигне от едната в другата, преминавайки само по проходими клетки по описания по-горе начин.
 
 Да се напише програма, в която се дефинира **рекурсивна** булева функция pathMatrix. Функцията да приема като параметри матрицата, нейната размерност, координати x1 и y1 на една клетка и x2 и y2 на друга клетка и да връща true, ако има път между двете клетки, и false в противен случай.

#### Примери ####

```c++
4       //размерност на матрицата
0 0 1 0
0 1 1 0
0 1 0 1
0 0 0 1
0 1     //координати на първата клетка
2 2     //координати на втората клетка
// -> true

4       //размерност на матрицата
0 0 1 0
0 1 1 0
0 1 0 1
0 0 1 1
0 1     //координати на първата клетка
2 2     //координати на втората клетка
// -> false
```



